#! /usr/bin/env python3

import argparse
from ast import Tuple
import logging
from pathlib import Path
from typing import Optional

from extension_mapping import ALIAS_TO_EXTENSION_MAP
from user_interface.settings import Settings


def parse_cli_arguments() -> argparse.Namespace:
    """
    Parse command line arguments.

    Returns:
        argparse.Namespace: Parsed CLI arguments
    """
    parser = argparse.ArgumentParser(
        description="Make-it-Parquet!: Conversion of data files powered by DuckDB"
    )
    # Input path.
    parser.add_argument(
        "input_path", help="Path to the input file or directory", type=Path
    )
    # Output path.
    parser.add_argument(
        "-op", "--output_path", help="Specify output file path", type=Path
    )
    # Input format.
    parser.add_argument(
        "-i", "--input_format", help="Specify input file format", type=str
    )
    # Output format.
    parser.add_argument(
        "-o", "--output_format", help="Specify output file format", type=str
    )
    # Excel sheet.
    parser.add_argument("-s", "--sheet", help="Excel sheet (name or number)", type=str)
    # Excel range.
    parser.add_argument("-c", "--range", help="Excel range (e.g., A2:E7)", type=str)
    # Log level.
    parser.add_argument(
        "--log-level",
        help="Set the logging level (e.g., DEBUG, INFO, WARNING)",
        default="INFO",
    )
    # Parse arguments and create argparse.Namespace object (args).
    args = parser.parse_args()
    return args


def validate_format_inputs(settings: Settings) -> Tuple[Optional[str], Optional[str]]:
    """
    Validate input and output format arguments that were passed in directly from the command line.
    Does not interact with arguments generated by prompts.
    If no (valid) arguments are provided input_ext and output_ext will be None.

    Returns:
        Tuple[Optional[str], Optional[str]]: Validated input and output extensions
    """
    input_ext = validate_input_format(settings)
    output_ext = validate_output_format(settings)
    input_ext, output_ext = reset_extensions_if_same(
        input_ext, output_ext
    )
    settings.input_output_flags.set_cli_flags(input_ext, output_ext)
    # Return input and output extensions.
    return input_ext, output_ext    


def validate_input_format(settings: Settings) -> Optional[str]:
    """
    Validate input format.
    """
    if settings.args.input_format:
        if settings.args.input_format in ALIAS_TO_EXTENSION_MAP:
            input_ext = ALIAS_TO_EXTENSION_MAP[settings.args.input_format]
        else:
            logging.error(
                f"Received invalid input format: {settings.args.input_format}\n Input format will be automatically detected."
            )
            input_ext = None
    else:
        input_ext = None
    return input_ext


def validate_output_format(settings: Settings) -> Optional[str]:
    """
    Validate output format.
    """
    if settings.args.output_format:
        if settings.args.output_format in ALIAS_TO_EXTENSION_MAP:
            output_ext = ALIAS_TO_EXTENSION_MAP[settings.args.output_format]
        else:
            logging.error(
                f"Received invalid output format: {settings.args.output_format}"
            )
            output_ext = None
    else:
        output_ext = None
    return output_ext


def reset_extensions_if_same(
    input_ext: Optional[str], output_ext: Optional[str]
) -> Tuple[Optional[str], Optional[str]]:
    """
    Reset input and output extensions if they are the same.
    """
    # Raise error if input and output formats are the same.
    if input_ext and output_ext:
        if input_ext == output_ext:
            logging.error(
                "Input and output extensions cannot be the same. Input extension will be automatically detected, please specify output extension."
            )
            input_ext = None #TODO: 16-Feb-2025: Review whether this is the best choice here. 
            output_ext = None
    return input_ext, output_ext
